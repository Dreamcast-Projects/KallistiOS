<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KallistiOS: DMA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KallistiOS<span id="projectnumber">&#160;git master</span>
   </div>
   <div id="projectbrief">Independent SDK for the Sega Dreamcast</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__pvr__dma.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">DMA<div class="ingroups"><a class="el" href="group__video.html">Video</a> &raquo; <a class="el" href="group__pvr.html">PowerVR API</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>PowerVR DMA driver  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pvr__dma__type.html">Transfer Modes</a></td></tr>
<tr class="memdesc:group__pvr__dma__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer modes with TA/PVR DMA and Store Queues <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1c983e6877a569204c25ec9e5ad48d63" id="r_ga1c983e6877a569204c25ec9e5ad48d63"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a>) (void *data)</td></tr>
<tr class="memdesc:ga1c983e6877a569204c25ec9e5ad48d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">PVR DMA interrupt callback type.  <br /></td></tr>
<tr class="separator:ga1c983e6877a569204c25ec9e5ad48d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3d92510391f4cfdbe06a531a69827e54" id="r_ga3d92510391f4cfdbe06a531a69827e54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d92510391f4cfdbe06a531a69827e54">pvr_dma_transfer</a> (const void *src, void *dest, size_t count, <a class="el" href="group__pvr__dma__type.html#ga7d772c6dfeec1493c31bb6a200cd3744">pvr_dma_type_t</a> type, int block, <a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a> callback, void *cbdata)</td></tr>
<tr class="memdesc:ga3d92510391f4cfdbe06a531a69827e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a DMA transfer to/from the TA/PVR RAM.  <br /></td></tr>
<tr class="separator:ga3d92510391f4cfdbe06a531a69827e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf646382b9252ce7ff46d346ad1bca523" id="r_gaf646382b9252ce7ff46d346ad1bca523"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf646382b9252ce7ff46d346ad1bca523">pvr_txr_load_dma</a> (const void *src, <a class="el" href="group__pvr__vram.html#ga621fa8a260d17a31b12d4155426d0fa4">pvr_ptr_t</a> dest, size_t count, int block, <a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a> callback, void *cbdata) <a class="el" href="group__system__macros.html#ga392e91d0f8a0af994874aadeed30534d">__depr</a>(&quot;Use <a class="el" href="#gab9fce8e20ebac9ff07500339bbec2987">pvr_dma_ta_load_txr</a> instead.&quot;)</td></tr>
<tr class="memdesc:gaf646382b9252ce7ff46d346ad1bca523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture using TA DMA.  <br /></td></tr>
<tr class="separator:gaf646382b9252ce7ff46d346ad1bca523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9fce8e20ebac9ff07500339bbec2987" id="r_gab9fce8e20ebac9ff07500339bbec2987"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab9fce8e20ebac9ff07500339bbec2987">pvr_dma_ta_load_txr</a> (const void *src, <a class="el" href="group__pvr__vram.html#ga621fa8a260d17a31b12d4155426d0fa4">pvr_ptr_t</a> dest, size_t count, int block, <a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a> callback, void *cbdata)</td></tr>
<tr class="memdesc:gab9fce8e20ebac9ff07500339bbec2987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture using TA DMA.  <br /></td></tr>
<tr class="separator:gab9fce8e20ebac9ff07500339bbec2987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffbd9e0f61dae3e4b9b4417ab7f264f8" id="r_gaffbd9e0f61dae3e4b9b4417ab7f264f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaffbd9e0f61dae3e4b9b4417ab7f264f8">pvr_dma_rb_load_txr</a> (const void *src, <a class="el" href="group__pvr__vram.html#ga621fa8a260d17a31b12d4155426d0fa4">pvr_ptr_t</a> dest, size_t count, int block, <a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a> callback, void *cbdata)</td></tr>
<tr class="memdesc:gaffbd9e0f61dae3e4b9b4417ab7f264f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture using PVR DMA.  <br /></td></tr>
<tr class="separator:gaffbd9e0f61dae3e4b9b4417ab7f264f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga308b01012bbe28dfbc0a4b8c680a9fc4" id="r_ga308b01012bbe28dfbc0a4b8c680a9fc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga308b01012bbe28dfbc0a4b8c680a9fc4">pvr_dma_download_txr</a> (const void *src, void *dest, size_t count, int block, <a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a> callback, void *cbdata)</td></tr>
<tr class="memdesc:ga308b01012bbe28dfbc0a4b8c680a9fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download a texture using PVR DMA.  <br /></td></tr>
<tr class="separator:ga308b01012bbe28dfbc0a4b8c680a9fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c43a18a5c44c04f14f7445e7e41dd6e" id="r_ga9c43a18a5c44c04f14f7445e7e41dd6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9c43a18a5c44c04f14f7445e7e41dd6e">pvr_dma_load_ta</a> (const void *src, size_t count, int block, <a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a> callback, void *cbdata)</td></tr>
<tr class="memdesc:ga9c43a18a5c44c04f14f7445e7e41dd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load vertex data to the TA using TA DMA.  <br /></td></tr>
<tr class="separator:ga9c43a18a5c44c04f14f7445e7e41dd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddc2155f9725e1c514299bc4f3e99efd" id="r_gaddc2155f9725e1c514299bc4f3e99efd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaddc2155f9725e1c514299bc4f3e99efd">pvr_dma_yuv_conv</a> (const void *src, size_t count, int block, <a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a> callback, void *cbdata)</td></tr>
<tr class="memdesc:gaddc2155f9725e1c514299bc4f3e99efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load yuv data to the YUV converter using TA DMA.  <br /></td></tr>
<tr class="separator:gaddc2155f9725e1c514299bc4f3e99efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04de1a27a256b15e1296961b13cb6b45" id="r_ga04de1a27a256b15e1296961b13cb6b45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga04de1a27a256b15e1296961b13cb6b45">pvr_dma_ready</a> (void) <a class="el" href="group__system__macros.html#ga392e91d0f8a0af994874aadeed30534d">__depr</a>(&quot;Use <a class="el" href="#ga8e61fe6cb891c5d29dd6cc69a787fe18">pvr_dma_ta_ready</a> instead.&quot;)</td></tr>
<tr class="memdesc:ga04de1a27a256b15e1296961b13cb6b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the TA DMA is inactive.  <br /></td></tr>
<tr class="separator:ga04de1a27a256b15e1296961b13cb6b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e61fe6cb891c5d29dd6cc69a787fe18" id="r_ga8e61fe6cb891c5d29dd6cc69a787fe18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e61fe6cb891c5d29dd6cc69a787fe18">pvr_dma_ta_ready</a> (void)</td></tr>
<tr class="memdesc:ga8e61fe6cb891c5d29dd6cc69a787fe18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the TA DMA is inactive.  <br /></td></tr>
<tr class="separator:ga8e61fe6cb891c5d29dd6cc69a787fe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1053b29573bbab8a654eecf285b6c32" id="r_gaf1053b29573bbab8a654eecf285b6c32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf1053b29573bbab8a654eecf285b6c32">pvr_dma_rb_ready</a> (void)</td></tr>
<tr class="memdesc:gaf1053b29573bbab8a654eecf285b6c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the PVR DMA is inactive.  <br /></td></tr>
<tr class="separator:gaf1053b29573bbab8a654eecf285b6c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad109fa463b781e04238895138e0a2a38" id="r_gad109fa463b781e04238895138e0a2a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad109fa463b781e04238895138e0a2a38">pvr_dma_init</a> (void)</td></tr>
<tr class="memdesc:gad109fa463b781e04238895138e0a2a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize TA/PVR DMA.  <br /></td></tr>
<tr class="separator:gad109fa463b781e04238895138e0a2a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea1ae7a936cd5952942d6039f00c9862" id="r_gaea1ae7a936cd5952942d6039f00c9862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaea1ae7a936cd5952942d6039f00c9862">pvr_dma_shutdown</a> (void)</td></tr>
<tr class="memdesc:gaea1ae7a936cd5952942d6039f00c9862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down TA/PVR DMA.  <br /></td></tr>
<tr class="separator:gaea1ae7a936cd5952942d6039f00c9862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862e89040f0b6a0649843f9e2f08ee9a" id="r_ga862e89040f0b6a0649843f9e2f08ee9a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga862e89040f0b6a0649843f9e2f08ee9a">pvr_sq_load</a> (void *dest, const void *src, size_t n, <a class="el" href="group__pvr__dma__type.html#ga7d772c6dfeec1493c31bb6a200cd3744">pvr_dma_type_t</a> type)</td></tr>
<tr class="memdesc:ga862e89040f0b6a0649843f9e2f08ee9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a block of memory to VRAM.  <br /></td></tr>
<tr class="separator:ga862e89040f0b6a0649843f9e2f08ee9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga279e1dc13ceda7c544ed72a9e4141fac" id="r_ga279e1dc13ceda7c544ed72a9e4141fac"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga279e1dc13ceda7c544ed72a9e4141fac">pvr_sq_set16</a> (void *dest, uint32_t c, size_t n, <a class="el" href="group__pvr__dma__type.html#ga7d772c6dfeec1493c31bb6a200cd3744">pvr_dma_type_t</a> type)</td></tr>
<tr class="memdesc:ga279e1dc13ceda7c544ed72a9e4141fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a block of PVR memory to a 16-bit value.  <br /></td></tr>
<tr class="separator:ga279e1dc13ceda7c544ed72a9e4141fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60be360851438cc0c0a0d8d9c4ec8230" id="r_ga60be360851438cc0c0a0d8d9c4ec8230"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga60be360851438cc0c0a0d8d9c4ec8230">pvr_sq_set32</a> (void *dest, uint32_t c, size_t n, <a class="el" href="group__pvr__dma__type.html#ga7d772c6dfeec1493c31bb6a200cd3744">pvr_dma_type_t</a> type)</td></tr>
<tr class="memdesc:ga60be360851438cc0c0a0d8d9c4ec8230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a block of PVR memory to a 32-bit value.  <br /></td></tr>
<tr class="separator:ga60be360851438cc0c0a0d8d9c4ec8230"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>PowerVR DMA driver </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga1c983e6877a569204c25ec9e5ad48d63" name="ga1c983e6877a569204c25ec9e5ad48d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c983e6877a569204c25ec9e5ad48d63">&#9670;&#160;</a></span>pvr_dma_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pvr_dma_callback_t) (void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PVR DMA interrupt callback type. </p>
<p>Functions that act as callbacks when DMA completes should be of this type. These functions will be called inside an interrupt context, so don't try to use anything that might stall.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>User data passed in to the <a class="el" href="#ga3d92510391f4cfdbe06a531a69827e54" title="Perform a DMA transfer to/from the TA/PVR RAM.">pvr_dma_transfer()</a> function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga308b01012bbe28dfbc0a4b8c680a9fc4" name="ga308b01012bbe28dfbc0a4b8c680a9fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga308b01012bbe28dfbc0a4b8c680a9fc4">&#9670;&#160;</a></span>pvr_dma_download_txr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_dma_download_txr </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cbdata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Download a texture using PVR DMA. </p>
<p>This is essentially a convenience wrapper for <a class="el" href="#ga3d92510391f4cfdbe06a531a69827e54" title="Perform a DMA transfer to/from the TA/PVR RAM.">pvr_dma_transfer()</a>, so all notes that apply to it also apply here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Where to copy to. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">dest</td><td>Where to copy from. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to copy. Must be a multiple of 32. </td></tr>
    <tr><td class="paramname">block</td><td>Non-zero if you want the function to block until the DMA completes. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to call upon completion of the DMA. </td></tr>
    <tr><td class="paramname">cbdata</td><td>Data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On failure. Sets errno as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EINPROGRESS</em> - DMA already in progress <br  />
<em>EFAULT</em> - src or dest is not 32-byte aligned <br  />
<em>EIO</em> - I/O error </dd></dl>

</div>
</div>
<a id="gad109fa463b781e04238895138e0a2a38" name="gad109fa463b781e04238895138e0a2a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad109fa463b781e04238895138e0a2a38">&#9670;&#160;</a></span>pvr_dma_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr_dma_init </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize TA/PVR DMA. </p>

</div>
</div>
<a id="ga9c43a18a5c44c04f14f7445e7e41dd6e" name="ga9c43a18a5c44c04f14f7445e7e41dd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c43a18a5c44c04f14f7445e7e41dd6e">&#9670;&#160;</a></span>pvr_dma_load_ta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_dma_load_ta </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cbdata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load vertex data to the TA using TA DMA. </p>
<p>This is essentially a convenience wrapper for <a class="el" href="#ga3d92510391f4cfdbe06a531a69827e54" title="Perform a DMA transfer to/from the TA/PVR RAM.">pvr_dma_transfer()</a>, so all notes that apply to it also apply here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Where to copy from. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to copy. Must be a multiple of 32. </td></tr>
    <tr><td class="paramname">block</td><td>Non-zero if you want the function to block until the DMA completes. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to call upon completion of the DMA. </td></tr>
    <tr><td class="paramname">cbdata</td><td>Data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On failure. Sets errno as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EINPROGRESS</em> - DMA already in progress <br  />
<em>EFAULT</em> - src is not 32-byte aligned <br  />
<em>EIO</em> - I/O error </dd></dl>

</div>
</div>
<a id="gaffbd9e0f61dae3e4b9b4417ab7f264f8" name="gaffbd9e0f61dae3e4b9b4417ab7f264f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffbd9e0f61dae3e4b9b4417ab7f264f8">&#9670;&#160;</a></span>pvr_dma_rb_load_txr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_dma_rb_load_txr </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pvr__vram.html#ga621fa8a260d17a31b12d4155426d0fa4">pvr_ptr_t</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cbdata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a texture using PVR DMA. </p>
<p>This is essentially a convenience wrapper for <a class="el" href="#ga3d92510391f4cfdbe06a531a69827e54" title="Perform a DMA transfer to/from the TA/PVR RAM.">pvr_dma_transfer()</a>, so all notes that apply to it also apply here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Where to copy from. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">dest</td><td>Where to copy to. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to copy. Must be a multiple of 32. </td></tr>
    <tr><td class="paramname">block</td><td>Non-zero if you want the function to block until the DMA completes. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to call upon completion of the DMA. </td></tr>
    <tr><td class="paramname">cbdata</td><td>Data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On failure. Sets errno as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EINPROGRESS</em> - DMA already in progress <br  />
<em>EFAULT</em> - src or dest is not 32-byte aligned <br  />
<em>EIO</em> - I/O error </dd></dl>

</div>
</div>
<a id="gaf1053b29573bbab8a654eecf285b6c32" name="gaf1053b29573bbab8a654eecf285b6c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1053b29573bbab8a654eecf285b6c32">&#9670;&#160;</a></span>pvr_dma_rb_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_dma_rb_ready </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the PVR DMA is inactive. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if there is no PVR DMA active, thus a DMA can begin or 0 if there is an active DMA. </dd></dl>

</div>
</div>
<a id="ga04de1a27a256b15e1296961b13cb6b45" name="ga04de1a27a256b15e1296961b13cb6b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04de1a27a256b15e1296961b13cb6b45">&#9670;&#160;</a></span>pvr_dma_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_dma_ready </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the TA DMA is inactive. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated</a></b></dt><dd>This function is formally deprecated, and should not be used in newly written code. Instead, please use <a class="el" href="#ga8e61fe6cb891c5d29dd6cc69a787fe18" title="Checks if the TA DMA is inactive.">pvr_dma_ta_ready()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if there is no TA DMA active, thus a DMA can begin or 0 if there is an active DMA. </dd></dl>

</div>
</div>
<a id="gaea1ae7a936cd5952942d6039f00c9862" name="gaea1ae7a936cd5952942d6039f00c9862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea1ae7a936cd5952942d6039f00c9862">&#9670;&#160;</a></span>pvr_dma_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr_dma_shutdown </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down TA/PVR DMA. </p>

</div>
</div>
<a id="gab9fce8e20ebac9ff07500339bbec2987" name="gab9fce8e20ebac9ff07500339bbec2987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9fce8e20ebac9ff07500339bbec2987">&#9670;&#160;</a></span>pvr_dma_ta_load_txr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_dma_ta_load_txr </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pvr__vram.html#ga621fa8a260d17a31b12d4155426d0fa4">pvr_ptr_t</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cbdata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a texture using TA DMA. </p>
<p>This is essentially a convenience wrapper for <a class="el" href="#ga3d92510391f4cfdbe06a531a69827e54" title="Perform a DMA transfer to/from the TA/PVR RAM.">pvr_dma_transfer()</a>, so all notes that apply to it also apply here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Where to copy from. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">dest</td><td>Where to copy to. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to copy. Must be a multiple of 32. </td></tr>
    <tr><td class="paramname">block</td><td>Non-zero if you want the function to block until the DMA completes. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to call upon completion of the DMA. </td></tr>
    <tr><td class="paramname">cbdata</td><td>Data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On failure. Sets errno as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EINPROGRESS</em> - DMA already in progress <br  />
<em>EFAULT</em> - src or dest is not 32-byte aligned <br  />
<em>EIO</em> - I/O error </dd></dl>

</div>
</div>
<a id="ga8e61fe6cb891c5d29dd6cc69a787fe18" name="ga8e61fe6cb891c5d29dd6cc69a787fe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e61fe6cb891c5d29dd6cc69a787fe18">&#9670;&#160;</a></span>pvr_dma_ta_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_dma_ta_ready </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the TA DMA is inactive. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if there is no TA DMA active, thus a DMA can begin or 0 if there is an active DMA. </dd></dl>

</div>
</div>
<a id="ga3d92510391f4cfdbe06a531a69827e54" name="ga3d92510391f4cfdbe06a531a69827e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d92510391f4cfdbe06a531a69827e54">&#9670;&#160;</a></span>pvr_dma_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_dma_transfer </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pvr__dma__type.html#ga7d772c6dfeec1493c31bb6a200cd3744">pvr_dma_type_t</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cbdata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a DMA transfer to/from the TA/PVR RAM. </p>
<p>This function copies a block of data to/from the TA/PVR or its memory via DMA. There are all kinds of constraints that must be fulfilled to actually do this, so make sure to read all the fine print with the parameter list.</p>
<p>If a callback is specified, it will be called in an interrupt context, so keep that in mind in writing the callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Where to copy from. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">dest</td><td>Where to copy to. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to copy. Must be a multiple of 32. </td></tr>
    <tr><td class="paramname">type</td><td>The type of DMA transfer to do (see list of modes). </td></tr>
    <tr><td class="paramname">block</td><td>Non-zero if you want the function to block until the DMA completes. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to call upon completion of the DMA. </td></tr>
    <tr><td class="paramname">cbdata</td><td>Data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On failure. Sets errno as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EINPROGRESS</em> - DMA already in progress <br  />
<em>EFAULT</em> - src or dest is not 32-byte aligned <br  />
<em>EIO</em> - I/O error</dd></dl>
<dl class="section see"><dt>See also</dt><dd>pvr_dma_modes </dd></dl>

</div>
</div>
<a id="gaddc2155f9725e1c514299bc4f3e99efd" name="gaddc2155f9725e1c514299bc4f3e99efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddc2155f9725e1c514299bc4f3e99efd">&#9670;&#160;</a></span>pvr_dma_yuv_conv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_dma_yuv_conv </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cbdata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load yuv data to the YUV converter using TA DMA. </p>
<p>This is essentially a convenience wrapper for <a class="el" href="#ga3d92510391f4cfdbe06a531a69827e54" title="Perform a DMA transfer to/from the TA/PVR RAM.">pvr_dma_transfer()</a>, so all notes that apply to it also apply here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Where to copy from. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to copy. Must be a multiple of 32. </td></tr>
    <tr><td class="paramname">block</td><td>Non-zero if you want the function to block until the DMA completes. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to call upon completion of the DMA. </td></tr>
    <tr><td class="paramname">cbdata</td><td>Data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On failure. Sets errno as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EINPROGRESS</em> - DMA already in progress <br  />
<em>EFAULT</em> - src is not 32-byte aligned <br  />
<em>EIO</em> - I/O error </dd></dl>

</div>
</div>
<a id="ga862e89040f0b6a0649843f9e2f08ee9a" name="ga862e89040f0b6a0649843f9e2f08ee9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga862e89040f0b6a0649843f9e2f08ee9a">&#9670;&#160;</a></span>pvr_sq_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pvr_sq_load </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pvr__dma__type.html#ga7d772c6dfeec1493c31bb6a200cd3744">pvr_dma_type_t</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a block of memory to VRAM. </p>
<p>This function is similar to <a class="el" href="group__store__queues.html#ga8dcb6016c825d951d5aacd15fd137b89" title="Copy a block of memory.">sq_cpy()</a>, but it has been optimized for writing to a destination residing within VRAM.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function cannot be used at the same time as a PVR DMA transfer.</dd></dl>
<p>The dest pointer must be at least 32-byte aligned and reside in video memory, the src pointer must be at least 8-byte aligned, and n must be a multiple of 32.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to copy to (32-byte aligned). </td></tr>
    <tr><td class="paramname">src</td><td>The address to copy from (32-bit (8-byte) aligned). </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to copy (multiple of 32). </td></tr>
    <tr><td class="paramname">type</td><td>The type of SQ/DMA transfer to do (see list of modes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value of dest.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga60be360851438cc0c0a0d8d9c4ec8230" title="Set a block of PVR memory to a 32-bit value.">pvr_sq_set32()</a> </dd></dl>

</div>
</div>
<a id="ga279e1dc13ceda7c544ed72a9e4141fac" name="ga279e1dc13ceda7c544ed72a9e4141fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga279e1dc13ceda7c544ed72a9e4141fac">&#9670;&#160;</a></span>pvr_sq_set16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pvr_sq_set16 </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pvr__dma__type.html#ga7d772c6dfeec1493c31bb6a200cd3744">pvr_dma_type_t</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a block of PVR memory to a 16-bit value. </p>
<p>This function is similar to <a class="el" href="group__store__queues.html#ga30f23e7f5106da1dc68c773b9e7306a5" title="Set a block of memory to a 16-bit value.">sq_set16()</a>, but it has been optimized for writing to a destination residing within VRAM.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function cannot be used at the same time as a PVR DMA transfer.</dd></dl>
<p>The dest pointer must be at least 32-byte aligned and reside in video memory, n must be a multiple of 32 and only the low 16-bits are used from c.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to begin setting at (32-byte aligned). </td></tr>
    <tr><td class="paramname">c</td><td>The value to set (in the low 16-bits). </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to set (multiple of 32). </td></tr>
    <tr><td class="paramname">type</td><td>The type of SQ/DMA transfer to do (see list of modes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value of dest.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga60be360851438cc0c0a0d8d9c4ec8230" title="Set a block of PVR memory to a 32-bit value.">pvr_sq_set32()</a> </dd></dl>

</div>
</div>
<a id="ga60be360851438cc0c0a0d8d9c4ec8230" name="ga60be360851438cc0c0a0d8d9c4ec8230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60be360851438cc0c0a0d8d9c4ec8230">&#9670;&#160;</a></span>pvr_sq_set32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pvr_sq_set32 </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pvr__dma__type.html#ga7d772c6dfeec1493c31bb6a200cd3744">pvr_dma_type_t</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a block of PVR memory to a 32-bit value. </p>
<p>This function is similar to <a class="el" href="group__store__queues.html#ga31a2bae1ddf089207a59b1dc29c3ffb4" title="Set a block of memory to a 32-bit value.">sq_set32()</a>, but it has been optimized for writing to a destination residing within VRAM.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function cannot be used at the same time as a PVR DMA transfer.</dd></dl>
<p>The dest pointer must be at least 32-byte aligned and reside in video memory, n must be a multiple of 32.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address to begin setting at (32-byte aligned). </td></tr>
    <tr><td class="paramname">c</td><td>The value to set. </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to set (multiple of 32). </td></tr>
    <tr><td class="paramname">type</td><td>The type of SQ/DMA transfer to do (see list of modes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value of dest.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga279e1dc13ceda7c544ed72a9e4141fac" title="Set a block of PVR memory to a 16-bit value.">pvr_sq_set16</a> </dd></dl>

</div>
</div>
<a id="gaf646382b9252ce7ff46d346ad1bca523" name="gaf646382b9252ce7ff46d346ad1bca523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf646382b9252ce7ff46d346ad1bca523">&#9670;&#160;</a></span>pvr_txr_load_dma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr_txr_load_dma </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pvr__vram.html#ga621fa8a260d17a31b12d4155426d0fa4">pvr_ptr_t</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga1c983e6877a569204c25ec9e5ad48d63">pvr_dma_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cbdata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a texture using TA DMA. </p>
<p>This is essentially a convenience wrapper for <a class="el" href="#ga3d92510391f4cfdbe06a531a69827e54" title="Perform a DMA transfer to/from the TA/PVR RAM.">pvr_dma_transfer()</a>, so all notes that apply to it also apply here.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated</a></b></dt><dd>This function is formally deprecated and should not be used in new code. Instead you should use the <a class="el" href="#gab9fce8e20ebac9ff07500339bbec2987" title="Load a texture using TA DMA.">pvr_dma_ta_load_txr()</a> function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Where to copy from. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">dest</td><td>Where to copy to. Must be 32-byte aligned. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to copy. Must be a multiple of 32. </td></tr>
    <tr><td class="paramname">block</td><td>Non-zero if you want the function to block until the DMA completes. </td></tr>
    <tr><td class="paramname">callback</td><td>A function to call upon completion of the DMA. </td></tr>
    <tr><td class="paramname">cbdata</td><td>Data to pass to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success. </td></tr>
    <tr><td class="paramname">-1</td><td>On failure. Sets errno as appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Conditions:</dt><dd><em>EINPROGRESS</em> - DMA already in progress <br  />
<em>EFAULT</em> - src or dest is not 32-byte aligned <br  />
<em>EIO</em> - I/O error </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
